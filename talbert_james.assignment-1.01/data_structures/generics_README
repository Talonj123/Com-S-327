'Psudo-generics':
  To facilitate matinence of the data structures, while allowing type-safe functionality, a psude-generic system has been created. All types and method names are based upon #define's that set the type of data that the structure works with, and what it is called. These identifiers are read from the TYPE and NAME macros. This system permits the use of a signle implementation to operate on all data types directly. The downside is that each new data type used increased the total amount of code, and each new type must be compiled separately and linked thereafter. The upsie is that maintaining the code is a lot simpler, and a user can easily create new versions by adding rules to a Makefile. The general makefile rule (for standard, non-pointer types) is:
  
  
      %_structure.o: structure.c structure_internal.h
          gcc -c structure.c -o $@ -DTYPE=$*
      
  To get the function prototypes into a .c of.h file, use:
  
      #define TYPE int /* or whatever standard, non-pointer type */
      #include "structure.h"
  
  The structure.h header will also clean up some temporary defines used by the header, that the _internal header leaves defined for the structure.c file, so do not use the _internal version for client files.
  To compile the structures for non-standard types (we'll get to pointers in a minute) the make rule is not generic, let's assume that a file "types.h" contains a definition for "my_type_t"
  
      my_type_t_structure.o: structure.c structure_internal.h types.h
	  gcc -c structure.c -o $@ -DTYPE=my_type_t -include types.h
	  
  So, the compilation gets the definition of the desired type included, otherwise lots of errors occur. For use in client code, just include the "types.h" header before the structure header. Now for pointers, they aren't that bad, but they require another macro: NAME, the NAME macro lets you change the name of the types/functions to be declred/defined (*'s in the middle of function names don't work) an example for int*
  
      int_pointer_structure.o: structure.c structure_internal.h
	  gcc -c structure.c -o $@ -DTYPE=int* -DNAME=int_pointer
	  
  And to bring in the prototypes:
  
      #define TYPE int*
      #define NAME int_pointer
      #include "structure.h"
      
  The NAME macro can also be used without a pointer-type and is quite useful with custom types with long names. The important thing is that all includes of the same structure in the same file must be have unique NAMES (by default NAME is is TYPE, so if NAMEs aren't specified, it's not an issue) if they act on unique TYPEs. If the names clash/overlay, the compiler will throw a symbol redifinition error.